package com.dakoto.datastructuresandalgorithms;

public class ToolsForStringsAndArraysAndNumbers
{

    public static void printToolsForStrings()
    {
//        https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/
        // shifting bits
        // character count
        // order of traversal
            // 1. reverse order
            // 2. pivot order
            // 3. odd/even properties
        // character arrays because strings in java are immutable
        // string builder. don't modify strings in loops
        // regexes
        // while, instead of for loops ***********************************
        // trackers
        // index manipulation
        // multiple scans
        // the only way you can think of the optimized way is by thinking about the brute force first. because what are you trying to optimize?
        //  never code your brute force
        // how many ways are the elements you deal with different?
        // pay attention to case: uppercase, lowercase,
        // pay attention to format: ascii, unicode, etc
        // it may be easier to compute indices (indexes)
        // ascii arrays for indexing into: it's really valid : ascii: 256, unicode:
        //UTF-8 uses the ASCII set for the first 128 characters. That's handy because it means ASCII text is also valid in UTF-8.

    }

    public static void printToolsForArraysAndNumbers()
    {
        // odd/even properties of problem
        // Math.max, Math.min, Math.abs properties of problem.
        // Modulus property of problem
        // bitwise ops xor, and, or
            // & is AND
            // | is OR
            // ^ is XOR
        // loop invariant
        // multiplying by 10 to get significant digits etc....
        // add, duplicate
        // while, instead of for loops ***********************************
        // trackers
        // index manipulation
        // multiple scans
        // the only way you can think of the optimized way is by thinking about the brute force first. because what are you trying to optimize?
        //  never code your brute force
        // how many ways are the elements you deal with different?
        // it may be easier to compute indices (indexes)
        // binary search
        // divide the problem into 3s or

    }

    /*


     */
}
